<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ROOT5 Omnichain Bridge | Community Test</title>
  
  <!-- External Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.min.js"></script>
  <script src="https://unpkg.com/@solana/web3.js@1.95.3/lib/index.iife.min.js"></script>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --primary: #6366f1;
      --primary-dark: #4f46e5;
      --secondary: #8b5cf6;
      --success: #10b981;
      --error: #ef4444;
      --warning: #f59e0b;
      --bg-dark: #0f172a;
      --bg-card: #1e293b;
      --bg-input: #334155;
      --text-primary: #f1f5f9;
      --text-secondary: #94a3b8;
      --border: #334155;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
      color: var(--text-primary);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
    }

    .header {
      text-align: center;
      margin-bottom: 40px;
      padding: 30px 20px;
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(99, 102, 241, 0.3);
    }

    .header h1 {
      font-size: 2.5rem;
      font-weight: 800;
      margin-bottom: 10px;
      background: linear-gradient(135deg, #fff 0%, #e0e7ff 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .header p {
      font-size: 1.1rem;
      opacity: 0.9;
    }

    .card {
      background: var(--bg-card);
      border-radius: 16px;
      padding: 30px;
      margin-bottom: 20px;
      border: 1px solid var(--border);
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }

    .card-title {
      font-size: 1.3rem;
      font-weight: 600;
      margin-bottom: 20px;
      color: var(--text-primary);
    }

    .wallet-section {
      display: flex;
      gap: 15px;
      align-items: center;
      margin-bottom: 20px;
    }

    .btn {
      padding: 12px 24px;
      border: none;
      border-radius: 10px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      justify-content: center;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      color: white;
    }

    .btn-primary:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(99, 102, 241, 0.4);
    }

    .btn-secondary {
      background: var(--bg-input);
      color: var(--text-primary);
      border: 1px solid var(--border);
    }

    .btn-secondary:hover:not(:disabled) {
      background: var(--border);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .connected-wallet {
      background: var(--bg-input);
      padding: 15px 20px;
      border-radius: 10px;
      border: 1px solid var(--border);
    }

    .connected-wallet-label {
      font-size: 0.85rem;
      color: var(--text-secondary);
      margin-bottom: 5px;
    }

    .connected-wallet-address {
      font-family: 'Courier New', monospace;
      font-size: 0.95rem;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .badge {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 0.75rem;
      font-weight: 600;
    }

    .badge-success {
      background: rgba(16, 185, 129, 0.2);
      color: var(--success);
    }

    .form-group {
      margin-bottom: 20px;
    }

    .form-label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      color: var(--text-primary);
    }

    .form-input, .form-select {
      width: 100%;
      padding: 12px 16px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--text-primary);
      font-size: 1rem;
      transition: all 0.3s;
    }

    .form-input:focus, .form-select:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
    }

    .chain-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .chain-card {
      background: var(--bg-input);
      padding: 20px;
      border-radius: 10px;
      border: 2px solid transparent;
      cursor: pointer;
      transition: all 0.3s;
    }

    .chain-card:hover {
      border-color: var(--primary);
      transform: translateY(-2px);
    }

    .chain-card.selected {
      border-color: var(--primary);
      background: rgba(99, 102, 241, 0.1);
    }

    .chain-card.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .chain-card.disabled:hover {
      border-color: transparent;
      transform: none;
    }

    .chain-name {
      font-weight: 600;
      margin-bottom: 5px;
    }

    .chain-balance {
      font-size: 0.9rem;
      color: var(--text-secondary);
    }

    .status-box {
      padding: 15px;
      border-radius: 10px;
      margin-top: 20px;
      border-left: 4px solid;
    }

    .status-info {
      background: rgba(59, 130, 246, 0.1);
      border-color: #3b82f6;
      color: #93c5fd;
    }

    .status-success {
      background: rgba(16, 185, 129, 0.1);
      border-color: var(--success);
      color: #6ee7b7;
    }

    .status-error {
      background: rgba(239, 68, 68, 0.1);
      border-color: var(--error);
      color: #fca5a5;
    }

    .status-warning {
      background: rgba(245, 158, 11, 0.1);
      border-color: var(--warning);
      color: #fcd34d;
    }

    .tx-link {
      color: var(--primary);
      text-decoration: none;
      font-weight: 600;
    }

    .tx-link:hover {
      text-decoration: underline;
    }

    /* Modal Styles */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(4px);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background: var(--bg-card);
      border-radius: 16px;
      padding: 30px;
      max-width: 500px;
      width: 90%;
      border: 1px solid var(--border);
    }

    .modal-title {
      font-size: 1.5rem;
      font-weight: 700;
      margin-bottom: 20px;
    }

    .wallet-option {
      background: var(--bg-input);
      padding: 16px 20px;
      border-radius: 10px;
      margin-bottom: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 15px;
      border: 2px solid transparent;
      transition: all 0.3s;
    }

    .wallet-option:hover {
      border-color: var(--primary);
      transform: translateX(5px);
    }

    .wallet-option.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .wallet-option.disabled:hover {
      border-color: transparent;
      transform: none;
    }

    .wallet-icon {
      font-size: 2rem;
    }

    .wallet-info h3 {
      font-size: 1.1rem;
      margin-bottom: 4px;
    }

    .wallet-info p {
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    .spinner {
      border: 3px solid rgba(255, 255, 255, 0.1);
      border-top-color: var(--primary);
      border-radius: 50%;
      width: 20px;
      height: 20px;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .loading {
      display: inline-flex;
      align-items: center;
      gap: 10px;
    }

    @media (max-width: 768px) {
      .header h1 {
        font-size: 2rem;
      }
      
      .chain-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Header -->
    <div class="header">
      <h1>üåâ ROOT5 Omnichain Bridge</h1>
      <p>Community Testing Interface - Send tokens across 6 testnets</p>
    </div>

    <!-- Wallet Connection Card -->
    <div class="card">
      <div class="card-title">üîê Wallet Connection</div>
      <div class="wallet-section">
        <button class="btn btn-primary" id="connectBtn" onclick="openWalletModal()">
          Connect Wallet
        </button>
        <div class="connected-wallet" id="walletInfo" style="display: none; flex: 1;">
          <div class="connected-wallet-label">Connected</div>
          <div class="connected-wallet-address">
            <span id="walletAddress">-</span>
            <span class="badge badge-success" id="walletChain">-</span>
          </div>
        </div>
      </div>
    </div>

    <!-- Bridge Interface Card -->
    <div class="card">
      <div class="card-title">üöÄ Bridge Tokens</div>
      
      <!-- Source Chain -->
      <div class="form-group">
        <label class="form-label">From Chain</label>
        <div class="chain-grid" id="sourceChainGrid">
          <!-- Populated by JS -->
        </div>
      </div>

      <!-- Amount Input -->
      <div class="form-group">
        <label class="form-label">Amount (ROOT5)</label>
        <input type="number" class="form-input" id="amountInput" placeholder="0.00" step="0.01" min="0">
        <div style="margin-top: 8px; font-size: 0.85rem; color: var(--text-secondary);">
          Balance: <span id="sourceBalance">-</span> ROOT5
        </div>
      </div>

      <!-- Destination Chain -->
      <div class="form-group">
        <label class="form-label">To Chain</label>
        <div class="chain-grid" id="destChainGrid">
          <!-- Populated by JS -->
        </div>
      </div>

      <!-- Recipient Address (optional for same address) -->
      <div class="form-group">
        <label class="form-label">Recipient Address (optional, defaults to your address)</label>
        <input type="text" class="form-input" id="recipientInput" placeholder="0x... or Solana address">
      </div>

      <!-- Bridge Button -->
      <button class="btn btn-primary" id="bridgeBtn" onclick="executeBridge()" style="width: 100%; font-size: 1.1rem;" disabled>
        Bridge Tokens
      </button>

      <!-- Status Box - Always visible -->
      <div id="statusBox" class="status-box status-info">
        Click "Connect Wallet" above to get started
      </div>
    </div>

    <!-- Info Card -->
    <div class="card">
      <div class="card-title">‚ÑπÔ∏è Information</div>
      <p style="color: var(--text-secondary); line-height: 1.6;">
        This is a testnet bridge for the ROOT5 community. You can transfer ROOT5 tokens between:
        <br><br>
        <strong>‚Ä¢ Ethereum Sepolia</strong><br>
        <strong>‚Ä¢ Arbitrum Sepolia</strong><br>
        <strong>‚Ä¢ Base Sepolia</strong><br>
        <strong>‚Ä¢ BSC Testnet</strong><br>
        <strong>‚Ä¢ Optimism Sepolia</strong><br>
        <strong>‚Ä¢ Solana Devnet</strong>
        <br><br>
        Get testnet tokens from faucets, then try bridging small amounts to test the omnichain functionality!
      </p>
    </div>

    <!-- Debug Console Card -->
    <div class="card" style="background: #1a1a2e;">
      <div class="card-title" style="display: flex; justify-content: space-between; align-items: center;">
        üõ†Ô∏è Debug Console
        <button class="btn btn-secondary" onclick="toggleDebug()" style="padding: 6px 12px; font-size: 0.85rem;">
          Toggle
        </button>
      </div>
      <div id="debugConsole" style="
        background: #0f0f1e; 
        padding: 15px; 
        border-radius: 8px; 
        font-family: 'Courier New', monospace; 
        font-size: 0.85rem; 
        max-height: 200px; 
        overflow-y: auto;
        color: #00ff00;
        display: none;
      ">
        <div id="debugLog">Console initialized...</div>
      </div>
    </div>
  </div>

  <!-- Wallet Connection Modal -->
  <div class="modal" id="walletModal">
    <div class="modal-content">
      <div class="modal-title">Connect Wallet</div>
      
      <div class="wallet-option" onclick="connectWallet('metamask')">
        <div class="wallet-icon">ü¶ä</div>
        <div class="wallet-info">
          <h3>MetaMask</h3>
          <p>Connect using MetaMask browser extension</p>
        </div>
      </div>

      <div class="wallet-option" onclick="connectWallet('phantom')">
        <div class="wallet-icon">üëª</div>
        <div class="wallet-info">
          <h3>Phantom</h3>
          <p>Connect using Phantom (Solana & EVM)</p>
        </div>
      </div>

      <div class="wallet-option" onclick="connectWallet('coinbase')">
        <div class="wallet-icon">üîµ</div>
        <div class="wallet-info">
          <h3>Coinbase Wallet</h3>
          <p>Connect using Coinbase Wallet</p>
        </div>
      </div>

      <button class="btn btn-secondary" onclick="closeWalletModal()" style="width: 100%; margin-top: 15px;">
        Cancel
      </button>
    </div>
  </div>

  <script>
    // ==================== CONFIGURATION ====================
    const CONFIG = {
      TOKEN_DECIMALS: 6,
      SOLANA_MINT: '9Z3t8mK2Svw5zmS6pwWCfZ6rcKw4QF5gFkHfh94DzkYN',
      SOLANA_OFT_PROGRAM: 'HhsXchaPXZh5FtcfhDrs3Nd9bEE7huqQwUEvmzxjZQUz',
      
      CHAINS: {
        sepolia: {
          name: 'Ethereum Sepolia',
          chainId: '0xaa36a7',
          rpc: 'https://rpc.sepolia.org',
          explorer: 'https://sepolia.etherscan.io',
          contract: '0x3932107F4cD2F6a5Ff2788641630A4bb0AB4Fca9',
          lzEid: 40161,
          icon: 'üî∑'
        },
        arbitrumSepolia: {
          name: 'Arbitrum Sepolia',
          chainId: '0x66eee',
          rpc: 'https://sepolia-rollup.arbitrum.io/rpc',
          explorer: 'https://sepolia.arbiscan.io',
          contract: '0xC1b958dDf560AB592831b65dFC6a7f63b2EFe07E',
          lzEid: 40231,
          icon: 'üîµ'
        },
        baseSepolia: {
          name: 'Base Sepolia',
          chainId: '0x14a34',
          rpc: 'https://sepolia.base.org',
          explorer: 'https://sepolia.basescan.org',
          contract: '0xC1b958dDf560AB592831b65dFC6a7f63b2EFe07E',
          lzEid: 40245,
          icon: 'üîµ'
        },
        bscTestnet: {
          name: 'BSC Testnet',
          chainId: '0x61',
          rpc: 'https://data-seed-prebsc-1-s1.binance.org:8545',
          explorer: 'https://testnet.bscscan.com',
          contract: '0xC1b958dDf560AB592831b65dFC6a7f63b2EFe07E',
          lzEid: 40102,
          icon: 'üü°'
        },
        optimismSepolia: {
          name: 'Optimism Sepolia',
          chainId: '0xaa37dc',
          rpc: 'https://sepolia.optimism.io',
          explorer: 'https://sepolia-optimism.etherscan.io',
          contract: '0xC1b958dDf560AB592831b65dFC6a7f63b2EFe07E',
          lzEid: 40232,
          icon: 'üî¥'
        },
        solanaDevnet: {
          name: 'Solana Devnet',
          chainId: 'solana',
          rpc: 'https://api.devnet.solana.com',
          explorer: 'https://explorer.solana.com',
          lzEid: 40168,
          icon: 'üü£'
        }
      }
    };

    // OFT ABI for LayerZero V2
    const OFT_ABI = [
      'function balanceOf(address account) view returns (uint256)',
      'function send((uint32 dstEid, bytes32 to, uint256 amountLD, uint256 minAmountLD, bytes extraOptions, bytes composeMsg, bytes oftCmd) calldata _sendParam, (uint256 nativeFee, uint256 lzTokenFee) calldata _fee, address _refundAddress) payable returns ((bytes32 guid, uint64 nonce, (uint256 nativeFee, uint256 lzTokenFee) fee))',
      'function quoteSend((uint32 dstEid, bytes32 to, uint256 amountLD, uint256 minAmountLD, bytes extraOptions, bytes composeMsg, bytes oftCmd) calldata _sendParam, bool _payInLzToken) view returns ((uint256 nativeFee, uint256 lzTokenFee) fee)'
    ];

    // ==================== STATE ====================
    let state = {
      wallet: null,
      walletType: null,
      provider: null,
      signer: null,
      connectedChain: null,
      sourceChain: null,
      destChain: null,
      solanaConnection: null,
      solanaPublicKey: null
    };

    // ==================== INITIALIZATION ====================
    function init() {
      renderChainGrids();
      updateBridgeButton();
    }

    function renderChainGrids() {
      const sourceGrid = document.getElementById('sourceChainGrid');
      const destGrid = document.getElementById('destChainGrid');
      
      sourceGrid.innerHTML = '';
      destGrid.innerHTML = '';
      
      Object.entries(CONFIG.CHAINS).forEach(([key, chain]) => {
        const sourceCard = createChainCard(key, chain, 'source');
        const destCard = createChainCard(key, chain, 'dest');
        sourceGrid.appendChild(sourceCard);
        destGrid.appendChild(destCard);
      });
    }

    function createChainCard(key, chain, type) {
      const card = document.createElement('div');
      card.className = 'chain-card';
      card.dataset.chain = key;
      card.innerHTML = `
        <div class="chain-name">${chain.icon} ${chain.name}</div>
        <div class="chain-balance" id="${type}-balance-${key}">Balance: -</div>
      `;
      
      card.onclick = () => selectChain(key, type);
      return card;
    }

    function selectChain(chainKey, type) {
      if (type === 'source') {
        // Deselect all source chains
        document.querySelectorAll('#sourceChainGrid .chain-card').forEach(c => c.classList.remove('selected'));
        // Select this one
        document.querySelector(`#sourceChainGrid .chain-card[data-chain="${chainKey}"]`).classList.add('selected');
        state.sourceChain = chainKey;
        
        // Update balance
        if (state.wallet) {
          loadBalance(chainKey);
        }
      } else {
        // Deselect all dest chains
        document.querySelectorAll('#destChainGrid .chain-card').forEach(c => c.classList.remove('selected'));
        // Select this one
        document.querySelector(`#destChainGrid .chain-card[data-chain="${chainKey}"]`).classList.add('selected');
        state.destChain = chainKey;
      }
      
      updateBridgeButton();
    }

    function updateBridgeButton() {
      const btn = document.getElementById('bridgeBtn');
      const canBridge = state.wallet && state.sourceChain && state.destChain && state.sourceChain !== state.destChain;
      btn.disabled = !canBridge;
    }

    // ==================== WALLET CONNECTION ====================
    function openWalletModal() {
      document.getElementById('walletModal').classList.add('active');
    }

    function closeWalletModal() {
      document.getElementById('walletModal').classList.remove('active');
    }

    async function connectWallet(walletType) {
      debugLog(`=== Connecting ${walletType} ===`);
      
      try {
        if (walletType === 'metamask') {
          await connectMetaMask();
        } else if (walletType === 'phantom') {
          await connectPhantom();
        } else if (walletType === 'coinbase') {
          await connectCoinbase();
        }
        
        closeWalletModal();
        showStatus('‚úÖ Wallet connected successfully!', 'success');
        updateBridgeButton();
      } catch (error) {
        debugLog(`‚ùå Connection failed: ${error.message}`);
        showStatus(`‚ùå Failed to connect: ${error.message}`, 'error');
        // Don't close modal on error so user can try again
      }
    }

    async function connectMetaMask() {
      debugLog('Attempting MetaMask connection...');
      
      if (!window.ethereum) {
        throw new Error('MetaMask not installed. Please install MetaMask from metamask.io');
      }
      
      debugLog('window.ethereum detected');
      
      try {
        // Request accounts
        const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
        debugLog(`Accounts received: ${accounts.length} account(s)`);
        
        if (!accounts || accounts.length === 0) {
          throw new Error('No accounts found. Please unlock MetaMask.');
        }
        
        state.provider = new ethers.providers.Web3Provider(window.ethereum);
        state.signer = state.provider.getSigner();
        state.wallet = accounts[0];
        state.walletType = 'metamask';
        
        debugLog(`Wallet address: ${state.wallet}`);
        
        // Get current chain
        const network = await state.provider.getNetwork();
        const chainIdHex = '0x' + network.chainId.toString(16);
        state.connectedChain = findChainByChainId(chainIdHex);
        
        debugLog(`Network: ${network.name} (ChainID: ${chainIdHex})`);
        debugLog(`Matched chain: ${state.connectedChain || 'Unknown'}`);
        
        updateWalletDisplay();
        
        // Listen for account/chain changes
        window.ethereum.on('accountsChanged', handleAccountsChanged);
        window.ethereum.on('chainChanged', () => window.location.reload());
        
        debugLog('‚úÖ MetaMask connected successfully');
      } catch (error) {
        debugLog(`‚ùå MetaMask error: ${error.message}`);
        throw new Error(`MetaMask connection failed: ${error.message}`);
      }
    }

    async function connectPhantom() {
      console.log('connectPhantom called');
      
      // Try Phantom for Solana first
      if (window.solana && window.solana.isPhantom) {
        console.log('Phantom Solana detected');
        try {
          const resp = await window.solana.connect();
          state.solanaPublicKey = resp.publicKey;
          state.wallet = resp.publicKey.toString();
          state.walletType = 'phantom-solana';
          state.connectedChain = 'solanaDevnet';
          state.solanaConnection = new solanaWeb3.Connection('https://api.devnet.solana.com', 'confirmed');
          
          console.log('Phantom Solana connected:', state.wallet);
          updateWalletDisplay();
          return;
        } catch (error) {
          console.error('Phantom Solana connection error:', error);
          throw new Error(`Phantom Solana connection failed: ${error.message}`);
        }
      }
      
      // Try Phantom for EVM
      if (window.phantom?.ethereum) {
        console.log('Phantom EVM detected');
        try {
          const accounts = await window.phantom.ethereum.request({ method: 'eth_requestAccounts' });
          
          if (!accounts || accounts.length === 0) {
            throw new Error('No accounts found');
          }
          
          state.provider = new ethers.providers.Web3Provider(window.phantom.ethereum);
          state.signer = state.provider.getSigner();
          state.wallet = accounts[0];
          state.walletType = 'phantom-evm';
          
          const network = await state.provider.getNetwork();
          const chainIdHex = '0x' + network.chainId.toString(16);
          state.connectedChain = findChainByChainId(chainIdHex);
          
          console.log('Phantom EVM connected:', state.wallet);
          updateWalletDisplay();
          return;
        } catch (error) {
          console.error('Phantom EVM connection error:', error);
          throw new Error(`Phantom EVM connection failed: ${error.message}`);
        }
      }
      
      throw new Error('Phantom wallet not found. Please install Phantom from phantom.app');
    }

    async function connectCoinbase() {
      console.log('connectCoinbase called');
      
      // Check if Coinbase Wallet is available
      // Coinbase Wallet injects itself as window.ethereum when it's the only wallet
      // or as window.coinbaseWalletExtension
      let provider = null;
      
      if (window.coinbaseWalletExtension) {
        provider = window.coinbaseWalletExtension;
      } else if (window.ethereum && window.ethereum.isCoinbaseWallet) {
        provider = window.ethereum;
      }
      
      if (!provider) {
        throw new Error('Coinbase Wallet not installed. Please install from coinbase.com/wallet');
      }
      
      console.log('Coinbase Wallet provider found');
      
      try {
        const accounts = await provider.request({ method: 'eth_requestAccounts' });
        console.log('Accounts:', accounts);
        
        if (!accounts || accounts.length === 0) {
          throw new Error('No accounts found');
        }
        
        state.provider = new ethers.providers.Web3Provider(provider);
        state.signer = state.provider.getSigner();
        state.wallet = accounts[0];
        state.walletType = 'coinbase';
        
        const network = await state.provider.getNetwork();
        const chainIdHex = '0x' + network.chainId.toString(16);
        state.connectedChain = findChainByChainId(chainIdHex);
        
        console.log('Coinbase Wallet connected:', state.wallet);
        updateWalletDisplay();
      } catch (error) {
        console.error('Coinbase Wallet connection error:', error);
        throw new Error(`Coinbase Wallet connection failed: ${error.message}`);
      }
    }

    function findChainByChainId(chainId) {
      for (const [key, chain] of Object.entries(CONFIG.CHAINS)) {
        if (chain.chainId === chainId) {
          return key;
        }
      }
      return null;
    }

    function handleAccountsChanged(accounts) {
      if (accounts.length === 0) {
        // Disconnected
        window.location.reload();
      } else {
        state.wallet = accounts[0];
        updateWalletDisplay();
      }
    }

    function updateWalletDisplay() {
      document.getElementById('connectBtn').style.display = 'none';
      document.getElementById('walletInfo').style.display = 'flex';
      
      const shortAddress = state.wallet.length > 42 
        ? `${state.wallet.slice(0, 4)}...${state.wallet.slice(-4)}`
        : `${state.wallet.slice(0, 6)}...${state.wallet.slice(-4)}`;
      
      document.getElementById('walletAddress').textContent = shortAddress;
      document.getElementById('walletChain').textContent = state.connectedChain 
        ? CONFIG.CHAINS[state.connectedChain].name 
        : 'Unknown';
    }

    // ==================== BALANCE LOADING ====================
    async function loadBalance(chainKey) {
      const chain = CONFIG.CHAINS[chainKey];
      const balanceEl = document.getElementById(`source-balance-${chainKey}`);
      
      try {
        let balance;
        
        if (chainKey === 'solanaDevnet') {
          if (!state.solanaConnection || !state.solanaPublicKey) {
            balanceEl.textContent = 'Not connected';
            return;
          }
          
          const mint = new solanaWeb3.PublicKey(CONFIG.SOLANA_MINT);
          const accounts = await state.solanaConnection.getParsedTokenAccountsByOwner(
            state.solanaPublicKey,
            { mint }
          );
          
          if (accounts.value.length > 0) {
            const amount = accounts.value[0].account.data.parsed.info.tokenAmount.amount;
            balance = Number(amount) / Math.pow(10, CONFIG.TOKEN_DECIMALS);
          } else {
            balance = 0;
          }
        } else {
          if (!state.provider || !state.wallet) {
            balanceEl.textContent = 'Not connected';
            return;
          }
          
          // Switch to the chain if needed
          await ensureChain(chainKey);
          
          const contract = new ethers.Contract(chain.contract, OFT_ABI, state.provider);
          const bal = await contract.balanceOf(state.wallet);
          balance = parseFloat(ethers.utils.formatUnits(bal, CONFIG.TOKEN_DECIMALS));
        }
        
        balanceEl.textContent = `Balance: ${balance.toFixed(2)} ROOT5`;
        
        // Update main balance display if this is the selected source chain
        if (state.sourceChain === chainKey) {
          document.getElementById('sourceBalance').textContent = balance.toFixed(2);
        }
      } catch (error) {
        console.error(`Error loading balance for ${chainKey}:`, error);
        balanceEl.textContent = 'Error loading';
      }
    }

    async function ensureChain(chainKey) {
      const chain = CONFIG.CHAINS[chainKey];
      
      if (chainKey === 'solanaDevnet') {
        // Can't switch to Solana from EVM wallet
        throw new Error('Please use Phantom wallet for Solana');
      }
      
      const currentChainId = await state.provider.send('eth_chainId', []);
      
      if (currentChainId === chain.chainId) {
        return; // Already on the right chain
      }
      
      try {
        await state.provider.send('wallet_switchEthereumChain', [{ chainId: chain.chainId }]);
      } catch (switchError) {
        // Chain not added, try to add it
        if (switchError.code === 4902) {
          await state.provider.send('wallet_addEthereumChain', [{
            chainId: chain.chainId,
            chainName: chain.name,
            rpcUrls: [chain.rpc],
            nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
            blockExplorerUrls: [chain.explorer]
          }]);
        } else {
          throw switchError;
        }
      }
      
      // Reload provider after switch
      state.provider = new ethers.providers.Web3Provider(window.ethereum);
      state.signer = state.provider.getSigner();
    }

    // ==================== BRIDGE EXECUTION ====================
    async function executeBridge() {
      if (!state.sourceChain || !state.destChain || !state.wallet) {
        showStatus('Please connect wallet and select chains', 'error');
        return;
      }
      
      const amount = document.getElementById('amountInput').value;
      if (!amount || parseFloat(amount) <= 0) {
        showStatus('Please enter a valid amount', 'error');
        return;
      }
      
      const btn = document.getElementById('bridgeBtn');
      btn.disabled = true;
      btn.innerHTML = '<div class="loading"><div class="spinner"></div> Bridging...</div>';
      
      try {
        if (state.sourceChain === 'solanaDevnet') {
          await bridgeFromSolana(amount);
        } else {
          await bridgeFromEVM(amount);
        }
      } catch (error) {
        console.error('Bridge error:', error);
        showStatus(`Bridge failed: ${error.message}`, 'error');
      } finally {
        btn.disabled = false;
        btn.innerHTML = 'Bridge Tokens';
      }
    }

    async function bridgeFromEVM(amount) {
      showStatus('Preparing bridge transaction...', 'info');
      
      const sourceChain = CONFIG.CHAINS[state.sourceChain];
      const destChain = CONFIG.CHAINS[state.destChain];
      
      await ensureChain(state.sourceChain);
      
      const contract = new ethers.Contract(sourceChain.contract, OFT_ABI, state.signer);
      
      // Parse amount
      const amountLD = ethers.utils.parseUnits(amount, CONFIG.TOKEN_DECIMALS);
      
      // Get recipient address
      let recipientInput = document.getElementById('recipientInput').value.trim();
      let toAddressBytes32;
      
      if (!recipientInput) {
        // Use sender's address
        if (destChain.chainId === 'solana') {
          throw new Error('Please specify a Solana recipient address');
        }
        toAddressBytes32 = addressToBytes32(state.wallet);
      } else {
        if (destChain.chainId === 'solana') {
          toAddressBytes32 = solanaAddressToBytes32(recipientInput);
        } else {
          toAddressBytes32 = addressToBytes32(recipientInput);
        }
      }
      
      // Build send params
      const sendParam = {
        dstEid: destChain.lzEid,
        to: toAddressBytes32,
        amountLD: amountLD,
        minAmountLD: amountLD, // No slippage for now
        extraOptions: '0x',
        composeMsg: '0x',
        oftCmd: '0x'
      };
      
      // Quote the fee
      showStatus('Calculating bridge fee...', 'info');
      const quote = await contract.quoteSend(sendParam, false);
      
      showStatus(`Bridge fee: ${ethers.utils.formatEther(quote.nativeFee)} ETH - Sending transaction...`, 'info');
      
      // Send the transaction
      const tx = await contract.send(
        sendParam,
        { nativeFee: quote.nativeFee, lzTokenFee: 0 },
        state.wallet,
        { value: quote.nativeFee }
      );
      
      showStatus(`Transaction submitted! Hash: ${tx.hash}`, 'info');
      
      // Wait for confirmation
      const receipt = await tx.wait();
      
      const explorerLink = `${sourceChain.explorer}/tx/${tx.hash}`;
      showStatus(
        `‚úÖ Bridge successful! <a href="${explorerLink}" target="_blank" class="tx-link">View on ${sourceChain.name} explorer</a>`,
        'success'
      );
      
      // Reload balances
      setTimeout(() => {
        if (state.sourceChain) loadBalance(state.sourceChain);
      }, 2000);
    }

    async function bridgeFromSolana(amount) {
      showStatus('Solana ‚Üí EVM bridging will be enabled soon! For now, please bridge from EVM chains to Solana or between EVM chains.', 'warning');
      // Note: Solana OFT bridging requires calling the Solana program directly
      // This will be implemented in a future update
    }

    // ==================== UTILITY FUNCTIONS ====================
    function addressToBytes32(address) {
      // Remove 0x and pad to 32 bytes (64 hex chars)
      const addr = address.toLowerCase().replace('0x', '');
      return '0x' + addr.padStart(64, '0');
    }

    function solanaAddressToBytes32(solAddress) {
      // Simple base58 decode implementation
      const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
      const BASE = BigInt(58);
      
      let decoded = BigInt(0);
      for (let i = 0; i < solAddress.length; i++) {
        const char = solAddress[i];
        const value = ALPHABET.indexOf(char);
        if (value === -1) throw new Error('Invalid Solana address');
        decoded = decoded * BASE + BigInt(value);
      }
      
      // Convert to hex and pad to 32 bytes
      let hex = decoded.toString(16);
      hex = hex.padStart(64, '0');
      return '0x' + hex;
    }

    function showStatus(message, type) {
      const statusBox = document.getElementById('statusBox');
      statusBox.style.display = 'block';
      statusBox.className = `status-box status-${type}`;
      statusBox.innerHTML = message;
      debugLog(`[STATUS ${type.toUpperCase()}]: ${message.replace(/<[^>]*>/g, '')}`);
    }

    function toggleDebug() {
      const debugConsole = document.getElementById('debugConsole');
      debugConsole.style.display = debugConsole.style.display === 'none' ? 'block' : 'none';
    }

    function debugLog(message) {
      const debugLogEl = document.getElementById('debugLog');
      const timestamp = new Date().toLocaleTimeString();
      const logLine = `[${timestamp}] ${message}`;
      console.log(logLine);
      
      if (debugLogEl) {
        debugLogEl.innerHTML += `<div>${logLine}</div>`;
        debugLogEl.scrollTop = debugLogEl.scrollHeight;
      }
    }

    // ==================== INIT ====================
    window.addEventListener('load', () => {
      debugLog('=== ROOT5 Bridge Interface Loaded ===');
      debugLog('Checking for wallet providers...');
      debugLog(`window.ethereum: ${!!window.ethereum ? '‚úÖ Found' : '‚ùå Not found'}`);
      debugLog(`window.solana: ${!!window.solana ? '‚úÖ Found' : '‚ùå Not found'}`);
      debugLog(`window.phantom: ${!!window.phantom ? '‚úÖ Found' : '‚ùå Not found'}`);
      
      if (window.ethereum) {
        debugLog(`ethereum.isMetaMask: ${window.ethereum.isMetaMask}`);
        debugLog(`ethereum.isCoinbaseWallet: ${window.ethereum.isCoinbaseWallet}`);
      }
      
      init();
      
      showStatus('üëã Welcome! Click "Connect Wallet" to get started.', 'info');
    });
  </script>
</body>
</html>
