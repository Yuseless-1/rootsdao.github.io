<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ROOT5 Omnichain Bridge | Community Test (Fixed)</title>
  
  <!-- External Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.min.js"></script>
  <script src="https://unpkg.com/@solana/web3.js@1.95.3/lib/index.iife.min.js"></script>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --primary: #6366f1;
      --primary-dark: #4f46e5;
      --secondary: #8b5cf6;
      --success: #10b981;
      --error: #ef4444;
      --warning: #f59e0b;
      --bg-dark: #0f172a;
      --bg-card: #1e293b;
      --bg-input: #334155;
      --text-primary: #f1f5f9;
      --text-secondary: #94a3b8;
      --border: #334155;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
      color: var(--text-primary);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
    }

    .header {
      text-align: center;
      margin-bottom: 40px;
      padding: 30px 20px;
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(99, 102, 241, 0.3);
    }

    .header h1 {
      font-size: 2.5rem;
      font-weight: 800;
      margin-bottom: 10px;
      background: linear-gradient(135deg, #fff 0%, #e0e7ff 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .header p {
      font-size: 1.1rem;
      opacity: 0.9;
    }

    .card {
      background: var(--bg-card);
      border-radius: 16px;
      padding: 30px;
      margin-bottom: 20px;
      border: 1px solid var(--border);
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }

    .card-title {
      font-size: 1.3rem;
      font-weight: 600;
      margin-bottom: 20px;
      color: var(--text-primary);
    }

    .wallet-section {
      display: flex;
      gap: 15px;
      align-items: center;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .btn {
      padding: 12px 24px;
      border: none;
      border-radius: 10px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      justify-content: center;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      color: white;
    }

    .btn-primary:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(99, 102, 241, 0.4);
    }

    .btn-secondary {
      background: var(--bg-input);
      color: var(--text-primary);
      border: 1px solid var(--border);
    }

    .btn-secondary:hover:not(:disabled) {
      background: var(--border);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .connected-wallet {
      background: var(--bg-input);
      padding: 15px 20px;
      border-radius: 10px;
      border: 1px solid var(--border);
      flex: 1;
      min-width: 250px;
    }

    .connected-wallet-label {
      font-size: 0.85rem;
      color: var(--text-secondary);
      margin-bottom: 5px;
    }

    .connected-wallet-address {
      font-family: 'Courier New', monospace;
      font-size: 0.95rem;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .badge {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 0.75rem;
      font-weight: 600;
    }

    .badge-success {
      background: rgba(16, 185, 129, 0.2);
      color: var(--success);
    }

    .form-group {
      margin-bottom: 20px;
    }

    .form-label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      color: var(--text-primary);
    }

    .form-input, .form-select {
      width: 100%;
      padding: 12px 16px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--text-primary);
      font-size: 1rem;
      transition: all 0.3s;
    }

    .form-input:focus, .form-select:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
    }

    .chain-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .chain-card {
      background: var(--bg-input);
      padding: 20px;
      border-radius: 10px;
      border: 2px solid transparent;
      cursor: pointer;
      transition: all 0.3s;
    }

    .chain-card:hover:not(.disabled) {
      border-color: var(--primary);
      transform: translateY(-2px);
    }

    .chain-card.selected {
      border-color: var(--primary);
      background: rgba(99, 102, 241, 0.1);
    }

    .chain-card.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .chain-name {
      font-weight: 600;
      margin-bottom: 5px;
    }

    .chain-balance {
      font-size: 0.9rem;
      color: var(--text-secondary);
    }

    .status-box {
      padding: 15px;
      border-radius: 10px;
      margin-top: 20px;
      border-left: 4px solid;
    }

    .status-info {
      background: rgba(59, 130, 246, 0.1);
      border-color: #3b82f6;
      color: #93c5fd;
    }

    .status-success {
      background: rgba(16, 185, 129, 0.1);
      border-color: var(--success);
      color: #6ee7b7;
    }

    .status-error {
      background: rgba(239, 68, 68, 0.1);
      border-color: var(--error);
      color: #fca5a5;
    }

    .status-warning {
      background: rgba(245, 158, 11, 0.1);
      border-color: var(--warning);
      color: #fcd34d;
    }

    .tx-link {
      color: var(--primary);
      text-decoration: none;
      font-weight: 600;
    }

    .tx-link:hover {
      text-decoration: underline;
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(4px);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background: var(--bg-card);
      border-radius: 16px;
      padding: 30px;
      max-width: 500px;
      width: 90%;
      border: 1px solid var(--border);
    }

    .modal-title {
      font-size: 1.5rem;
      font-weight: 700;
      margin-bottom: 20px;
    }

    .wallet-option {
      background: var(--bg-input);
      padding: 16px 20px;
      border-radius: 10px;
      margin-bottom: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 15px;
      border: 2px solid transparent;
      transition: all 0.3s;
    }

    .wallet-option:hover:not(.disabled) {
      border-color: var(--primary);
      transform: translateX(5px);
    }

    .wallet-option.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .wallet-icon {
      font-size: 2rem;
    }

    .wallet-info h3 {
      font-size: 1.1rem;
      margin-bottom: 4px;
    }

    .wallet-info p {
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    .spinner {
      border: 3px solid rgba(255, 255, 255, 0.1);
      border-top-color: var(--primary);
      border-radius: 50%;
      width: 20px;
      height: 20px;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .loading {
      display: inline-flex;
      align-items: center;
      gap: 10px;
    }

    @media (max-width: 768px) {
      .header h1 {
        font-size: 2rem;
      }
      
      .chain-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Header -->
    <div class="header">
      <h1>üåâ ROOT5 Omnichain Bridge (Fixed)</h1>
      <p>Fully Working Community Testing Interface - Send tokens across 6 testnets</p>
    </div>

    <!-- Wallet Connection Card -->
    <div class="card">
      <div class="card-title">üîê Wallet Connection</div>
      <div class="wallet-section">
        <button class="btn btn-primary" id="connectBtn" onclick="openWalletModal()">
          Connect Wallet
        </button>
        <div class="connected-wallet" id="walletInfo" style="display: none;">
          <div class="connected-wallet-label">Connected</div>
          <div class="connected-wallet-address">
            <span id="walletAddress">-</span>
            <span class="badge badge-success" id="walletChain">-</span>
          </div>
        </div>
        <button class="btn btn-secondary" id="disconnectBtn" onclick="disconnectWallet()" style="display: none;">
          Disconnect
        </button>
      </div>
    </div>

    <!-- Bridge Interface Card -->
    <div class="card">
      <div class="card-title">üöÄ Bridge Tokens</div>
      
      <!-- Source Chain -->
      <div class="form-group">
        <label class="form-label">From Chain</label>
        <div class="chain-grid" id="sourceChainGrid">
          <!-- Populated by JS -->
        </div>
      </div>

      <!-- Amount Input -->
      <div class="form-group">
        <label class="form-label">Amount (ROOT5)</label>
        <input type="number" class="form-input" id="amountInput" placeholder="0.00" step="0.01" min="0">
        <div style="margin-top: 8px; font-size: 0.85rem; color: var(--text-secondary);">
          Balance: <span id="sourceBalance">-</span> ROOT5
        </div>
      </div>

      <!-- Destination Chain -->
      <div class="form-group">
        <label class="form-label">To Chain</label>
        <div class="chain-grid" id="destChainGrid">
          <!-- Populated by JS -->
        </div>
      </div>

      <!-- Recipient Address -->
      <div class="form-group">
        <label class="form-label">Recipient Address (optional, defaults to your address)</label>
        <input type="text" class="form-input" id="recipientInput" placeholder="0x... or Solana address">
      </div>

      <!-- Bridge Button -->
      <button class="btn btn-primary" id="bridgeBtn" onclick="executeBridge()" style="width: 100%; font-size: 1.1rem;" disabled>
        Bridge Tokens
      </button>

      <!-- Status Box -->
      <div id="statusBox" class="status-box status-info">
        Click "Connect Wallet" above to get started
      </div>
    </div>

    <!-- Info Card -->
    <div class="card">
      <div class="card-title">‚ÑπÔ∏è Information</div>
      <p style="color: var(--text-secondary); line-height: 1.6;">
        <strong>‚úÖ FIXED FEATURES:</strong><br>
        ‚Ä¢ Multi-wallet detection (MetaMask, Phantom, Coinbase)<br>
        ‚Ä¢ Automatic network switching<br>
        ‚Ä¢ Modal auto-close after connection<br>
        ‚Ä¢ Phantom Solana & EVM support<br>
        ‚Ä¢ Complete error handling<br>
        <br>
        <strong>SUPPORTED TESTNETS:</strong><br>
        ‚Ä¢ Ethereum Sepolia<br>
        ‚Ä¢ Arbitrum Sepolia<br>
        ‚Ä¢ Base Sepolia<br>
        ‚Ä¢ BSC Testnet<br>
        ‚Ä¢ Optimism Sepolia<br>
        ‚Ä¢ Solana Devnet<br>
      </p>
    </div>
  </div>

  <!-- Wallet Connection Modal -->
  <div class="modal" id="walletModal" onclick="handleModalClick(event)">
    <div class="modal-content" onclick="event.stopPropagation()">
      <div class="modal-title">Connect Wallet</div>
      
      <div class="wallet-option" onclick="connectWallet('metamask')">
        <div class="wallet-icon">ü¶ä</div>
        <div class="wallet-info">
          <h3>MetaMask</h3>
          <p>Connect using MetaMask browser extension</p>
        </div>
      </div>

      <div class="wallet-option" onclick="connectWallet('phantom')">
        <div class="wallet-icon">üëª</div>
        <div class="wallet-info">
          <h3>Phantom</h3>
          <p>Connect using Phantom (Solana & EVM)</p>
        </div>
      </div>

      <div class="wallet-option" onclick="connectWallet('coinbase')">
        <div class="wallet-icon">üîµ</div>
        <div class="wallet-info">
          <h3>Coinbase Wallet</h3>
          <p>Connect using Coinbase Wallet</p>
        </div>
      </div>

      <button class="btn btn-secondary" onclick="closeWalletModal()" style="width: 100%; margin-top: 15px;">
        Cancel
      </button>
    </div>
  </div>

  <script>
    // ==================== CONFIGURATION ====================
    const CONFIG = {
      TOKEN_DECIMALS: 6,
      SOLANA_MINT: '9Z3t8mK2Svw5zmS6pwWCfZ6rcKw4QF5gFkHfh94DzkYN',
      SOLANA_OFT_PROGRAM: 'HhsXchaPXZh5FtcfhDrs3Nd9bEE7huqQwUEvmzxjZQUz',
      SOLANA_OFT_STORE: '6k4a54QsewbaujFm7XiLTYzF5VFz6R51za9wUHwxsJGn',
      
      CHAINS: {
        sepolia: {
          name: 'Ethereum Sepolia',
          chainId: '0xaa36a7',
          chainIdDecimal: 11155111,
          rpc: 'https://rpc.sepolia.org',
          explorer: 'https://sepolia.etherscan.io',
          contract: '0x3932107F4cD2F6a5Ff2788641630A4bb0AB4Fca9',
          lzEid: 40161,
          icon: 'üî∑'
        },
        arbitrumSepolia: {
          name: 'Arbitrum Sepolia',
          chainId: '0x66eee',
          chainIdDecimal: 421614,
          rpc: 'https://sepolia-rollup.arbitrum.io/rpc',
          explorer: 'https://sepolia.arbiscan.io',
          contract: '0xC1b958dDf560AB592831b65dFC6a7f63b2EFe07E',
          lzEid: 40231,
          icon: 'üîµ'
        },
        baseSepolia: {
          name: 'Base Sepolia',
          chainId: '0x14a34',
          chainIdDecimal: 84532,
          rpc: 'https://sepolia.base.org',
          explorer: 'https://sepolia.basescan.org',
          contract: '0xC1b958dDf560AB592831b65dFC6a7f63b2EFe07E',
          lzEid: 40245,
          icon: 'üîµ'
        },
        bscTestnet: {
          name: 'BSC Testnet',
          chainId: '0x61',
          chainIdDecimal: 97,
          rpc: 'https://data-seed-prebsc-1-s1.binance.org:8545',
          explorer: 'https://testnet.bscscan.com',
          contract: '0xC1b958dDf560AB592831b65dFC6a7f63b2EFe07E',
          lzEid: 40102,
          icon: 'üü°'
        },
        optimismSepolia: {
          name: 'Optimism Sepolia',
          chainId: '0xaa37dc',
          chainIdDecimal: 11155420,
          rpc: 'https://sepolia.optimism.io',
          explorer: 'https://sepolia-optimism.etherscan.io',
          contract: '0xC1b958dDf560AB592831b65dFC6a7f63b2EFe07E',
          lzEid: 40232,
          icon: 'üî¥'
        },
        solanaDevnet: {
          name: 'Solana Devnet',
          chainId: 'solana',
          chainIdDecimal: null,
          rpc: 'https://api.devnet.solana.com',
          explorer: 'https://explorer.solana.com',
          lzEid: 40168,
          icon: 'üü£'
        }
      }
    };

    // OFT ABI for LayerZero V2
    const OFT_ABI = [
      'function balanceOf(address account) view returns (uint256)',
      'function send((uint32 dstEid, bytes32 to, uint256 amountLD, uint256 minAmountLD, bytes extraOptions, bytes composeMsg, bytes oftCmd) calldata _sendParam, (uint256 nativeFee, uint256 lzTokenFee) calldata _fee, address _refundAddress) payable returns ((bytes32 guid, uint64 nonce, (uint256 nativeFee, uint256 lzTokenFee) fee))',
      'function quoteSend((uint32 dstEid, bytes32 to, uint256 amountLD, uint256 minAmountLD, bytes extraOptions, bytes composeMsg, bytes oftCmd) calldata _sendParam, bool _payInLzToken) view returns ((uint256 nativeFee, uint256 lzTokenFee) fee)'
    ];

    // ==================== STATE ====================
    let state = {
      wallet: null,
      walletType: null,
      provider: null,
      signer: null,
      connectedChain: null,
      sourceChain: null,
      destChain: null,
      solanaConnection: null,
      solanaPublicKey: null
    };

    // ==================== UTILITY FUNCTIONS ====================
    function log(message, type = 'info') {
      const timestamp = new Date().toLocaleTimeString();
      const prefix = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : '‚ÑπÔ∏è';
      console.log(`[${timestamp}] ${prefix} ${message}`);
    }

    function showStatus(message, type) {
      const statusBox = document.getElementById('statusBox');
      statusBox.style.display = 'block';
      statusBox.className = `status-box status-${type}`;
      statusBox.innerHTML = message;
      log(message.replace(/<[^>]*>/g, ''), type);
    }

    // ==================== WALLET DETECTION ====================
    function detectWallets() {
      const wallets = {
        metamask: false,
        phantom: false,
        phantomSolana: false,
        coinbase: false
      };

      // Detect MetaMask
      if (window.ethereum) {
        // Check for MetaMask-specific provider
        if (window.ethereum.isMetaMask && !window.ethereum.isPhantom) {
          wallets.metamask = true;
        }
        // Also check for separate MetaMask provider in case of multiple wallets
        if (window.ethereum.providers) {
          const metamaskProvider = window.ethereum.providers.find(p => p.isMetaMask && !p.isPhantom);
          if (metamaskProvider) wallets.metamask = true;
        }
      }

      // Detect Phantom
      if (window.phantom?.ethereum) {
        wallets.phantom = true;
      }
      if (window.solana && window.solana.isPhantom) {
        wallets.phantomSolana = true;
      }

      // Detect Coinbase Wallet
      if (window.coinbaseWalletExtension || (window.ethereum && window.ethereum.isCoinbaseWallet)) {
        wallets.coinbase = true;
      }

      log(`Detected wallets: ${JSON.stringify(wallets)}`);
      return wallets;
    }

    function getMetaMaskProvider() {
      if (!window.ethereum) return null;
      
      // If there are multiple providers, find MetaMask
      if (window.ethereum.providers) {
        return window.ethereum.providers.find(p => p.isMetaMask && !p.isPhantom);
      }
      
      // Single provider - check if it's MetaMask
      if (window.ethereum.isMetaMask && !window.ethereum.isPhantom) {
        return window.ethereum;
      }
      
      return null;
    }

    function getPhantomEVMProvider() {
      return window.phantom?.ethereum || null;
    }

    function getCoinbaseProvider() {
      if (window.coinbaseWalletExtension) {
        return window.coinbaseWalletExtension;
      }
      if (window.ethereum && window.ethereum.isCoinbaseWallet) {
        return window.ethereum;
      }
      return null;
    }

    // ==================== MODAL MANAGEMENT ====================
    function openWalletModal() {
      const modal = document.getElementById('walletModal');
      modal.classList.add('active');
      document.body.style.overflow = 'hidden';
    }

    function closeWalletModal() {
      const modal = document.getElementById('walletModal');
      modal.classList.remove('active');
      document.body.style.overflow = 'auto';
    }

    function handleModalClick(event) {
      if (event.target.id === 'walletModal') {
        closeWalletModal();
      }
    }

    // ==================== WALLET CONNECTION ====================
    async function connectWallet(walletType) {
      log(`Attempting to connect ${walletType}...`);
      
      try {
        if (walletType === 'metamask') {
          await connectMetaMask();
        } else if (walletType === 'phantom') {
          await connectPhantom();
        } else if (walletType === 'coinbase') {
          await connectCoinbase();
        }
        
        // Close modal AFTER successful connection
        closeWalletModal();
        showStatus('‚úÖ Wallet connected successfully!', 'success');
        updateBridgeButton();
      } catch (error) {
        log(`Connection failed: ${error.message}`, 'error');
        showStatus(`‚ùå Failed to connect: ${error.message}`, 'error');
      }
    }

    async function connectMetaMask() {
      const provider = getMetaMaskProvider();
      
      if (!provider) {
        throw new Error('MetaMask not found. Please install MetaMask extension.');
      }
      
      log('MetaMask detected, requesting accounts...');
      
      try {
        const accounts = await provider.request({ method: 'eth_requestAccounts' });
        
        if (!accounts || accounts.length === 0) {
          throw new Error('No accounts found. Please unlock MetaMask.');
        }
        
        // Create provider and signer
        state.provider = new ethers.providers.Web3Provider(provider, 'any');
        state.signer = state.provider.getSigner();
        state.wallet = accounts[0];
        state.walletType = 'metamask';
        
        // Get current chain
        const network = await state.provider.getNetwork();
        const chainIdHex = '0x' + network.chainId.toString(16);
        state.connectedChain = findChainByChainId(chainIdHex) || 'sepolia';
        
        log(`‚úÖ MetaMask connected: ${state.wallet.slice(0, 6)}...${state.wallet.slice(-4)}`);
        log(`Network: ${state.connectedChain}`);
        
        updateWalletDisplay();
        
        // Setup event listeners
        provider.on('accountsChanged', handleAccountsChanged);
        provider.on('chainChanged', handleChainChanged);
        
      } catch (error) {
        if (error.code === 4001) {
          throw new Error('Connection rejected by user');
        } else if (error.code === -32002) {
          throw new Error('Connection request pending. Please check MetaMask.');
        }
        throw error;
      }
    }

    async function connectPhantom() {
      log('Checking for Phantom wallet...');
      
      // Try Phantom Solana first
      if (window.solana && window.solana.isPhantom) {
        log('Phantom Solana detected');
        try {
          const resp = await window.solana.connect();
          state.solanaPublicKey = resp.publicKey;
          state.wallet = resp.publicKey.toString();
          state.walletType = 'phantom-solana';
          state.connectedChain = 'solanaDevnet';
          state.solanaConnection = new solanaWeb3.Connection(CONFIG.CHAINS.solanaDevnet.rpc, 'confirmed');
          
          log(`‚úÖ Phantom Solana connected: ${state.wallet.slice(0, 6)}...${state.wallet.slice(-4)}`);
          
          // Setup Solana event listeners
          window.solana.on('disconnect', () => {
            log('Phantom Solana disconnected');
            resetState();
          });
          
          updateWalletDisplay();
          return;
        } catch (error) {
          log(`Phantom Solana connection failed: ${error.message}`, 'error');
          throw new Error(`Phantom Solana: ${error.message}`);
        }
      }
      
      // Try Phantom EVM
      const phantomEVM = getPhantomEVMProvider();
      if (phantomEVM) {
        log('Phantom EVM detected');
        try {
          const accounts = await phantomEVM.request({ method: 'eth_requestAccounts' });
          
          if (!accounts || accounts.length === 0) {
            throw new Error('No accounts found');
          }
          
          state.provider = new ethers.providers.Web3Provider(phantomEVM, 'any');
          state.signer = state.provider.getSigner();
          state.wallet = accounts[0];
          state.walletType = 'phantom-evm';
          
          const network = await state.provider.getNetwork();
          const chainIdHex = '0x' + network.chainId.toString(16);
          state.connectedChain = findChainByChainId(chainIdHex) || 'sepolia';
          
          log(`‚úÖ Phantom EVM connected: ${state.wallet.slice(0, 6)}...${state.wallet.slice(-4)}`);
          
          updateWalletDisplay();
          
          phantomEVM.on('accountsChanged', handleAccountsChanged);
          phantomEVM.on('chainChanged', handleChainChanged);
          
          return;
        } catch (error) {
          log(`Phantom EVM connection failed: ${error.message}`, 'error');
          throw new Error(`Phantom EVM: ${error.message}`);
        }
      }
      
      throw new Error('Phantom wallet not found. Please install Phantom from phantom.app');
    }

    async function connectCoinbase() {
      const provider = getCoinbaseProvider();
      
      if (!provider) {
        throw new Error('Coinbase Wallet not found. Please install from coinbase.com/wallet');
      }
      
      log('Coinbase Wallet detected, requesting accounts...');
      
      try {
        const accounts = await provider.request({ method: 'eth_requestAccounts' });
        
        if (!accounts || accounts.length === 0) {
          throw new Error('No accounts found');
        }
        
        state.provider = new ethers.providers.Web3Provider(provider, 'any');
        state.signer = state.provider.getSigner();
        state.wallet = accounts[0];
        state.walletType = 'coinbase';
        
        const network = await state.provider.getNetwork();
        const chainIdHex = '0x' + network.chainId.toString(16);
        state.connectedChain = findChainByChainId(chainIdHex) || 'sepolia';
        
        log(`‚úÖ Coinbase Wallet connected: ${state.wallet.slice(0, 6)}...${state.wallet.slice(-4)}`);
        
        updateWalletDisplay();
        
        provider.on('accountsChanged', handleAccountsChanged);
        provider.on('chainChanged', handleChainChanged);
        
      } catch (error) {
        if (error.code === 4001) {
          throw new Error('Connection rejected by user');
        }
        throw error;
      }
    }

    function disconnectWallet() {
      if (state.walletType === 'phantom-solana' && window.solana) {
        window.solana.disconnect();
      }
      resetState();
      showStatus('Wallet disconnected', 'info');
    }

    function resetState() {
      state = {
        wallet: null,
        walletType: null,
        provider: null,
        signer: null,
        connectedChain: null,
        sourceChain: null,
        destChain: null,
        solanaConnection: null,
        solanaPublicKey: null
      };
      
      document.getElementById('connectBtn').style.display = 'inline-flex';
      document.getElementById('walletInfo').style.display = 'none';
      document.getElementById('disconnectBtn').style.display = 'none';
      
      renderChainGrids();
      updateBridgeButton();
    }

    // ==================== EVENT HANDLERS ====================
    function handleAccountsChanged(accounts) {
      if (accounts.length === 0) {
        log('Wallet locked or disconnected');
        resetState();
      } else {
        log(`Account changed to ${accounts[0]}`);
        state.wallet = accounts[0];
        updateWalletDisplay();
      }
    }

    function handleChainChanged(chainId) {
      log(`Chain changed to ${chainId}, reloading...`);
      window.location.reload();
    }

    // ==================== CHAIN MANAGEMENT ====================
    function findChainByChainId(chainId) {
      for (const [key, chain] of Object.entries(CONFIG.CHAINS)) {
        if (chain.chainId === chainId.toLowerCase()) {
          return key;
        }
      }
      return null;
    }

    async function ensureChain(chainKey) {
      const chain = CONFIG.CHAINS[chainKey];
      
      if (chainKey === 'solanaDevnet') {
        throw new Error('Cannot switch to Solana from EVM wallet. Please reconnect with Phantom.');
      }
      
      if (!state.provider) {
        throw new Error('No provider available');
      }
      
      try {
        const currentChainId = await state.provider.send('eth_chainId', []);
        
        if (currentChainId.toLowerCase() === chain.chainId.toLowerCase()) {
          log(`Already on ${chain.name}`);
          state.connectedChain = chainKey;
          return;
        }
        
        log(`Switching to ${chain.name}...`);
        
        try {
          await state.provider.send('wallet_switchEthereumChain', [{ chainId: chain.chainId }]);
          log(`‚úÖ Switched to ${chain.name}`);
        } catch (switchError) {
          // Chain not added to wallet
          if (switchError.code === 4902) {
            log(`Adding ${chain.name} to wallet...`);
            await state.provider.send('wallet_addEthereumChain', [{
              chainId: chain.chainId,
              chainName: chain.name,
              rpcUrls: [chain.rpc],
              nativeCurrency: {
                name: 'ETH',
                symbol: 'ETH',
                decimals: 18
              },
              blockExplorerUrls: [chain.explorer]
            }]);
            log(`‚úÖ Added and switched to ${chain.name}`);
          } else {
            throw switchError;
          }
        }
        
        state.connectedChain = chainKey;
        
        // Refresh provider after switch
        const provider = state.walletType === 'metamask' ? getMetaMaskProvider() : 
                        state.walletType === 'phantom-evm' ? getPhantomEVMProvider() :
                        getCoinbaseProvider();
        state.provider = new ethers.providers.Web3Provider(provider, 'any');
        state.signer = state.provider.getSigner();
        
        updateWalletDisplay();
        await loadBalance(chainKey);
        
      } catch (error) {
        log(`Failed to switch chain: ${error.message}`, 'error');
        throw new Error(`Could not switch to ${chain.name}. Please switch manually in your wallet.`);
      }
    }

    // ==================== BALANCE LOADING ====================
    async function loadBalance(chainKey) {
      const chain = CONFIG.CHAINS[chainKey];
      const balanceEl = document.getElementById(`source-balance-${chainKey}`);
      
      if (!balanceEl) return;
      
      try {
        let balance;
        
        if (chainKey === 'solanaDevnet') {
          if (!state.solanaConnection || !state.solanaPublicKey) {
            balanceEl.textContent = 'Connect Phantom';
            return;
          }
          
          const mint = new solanaWeb3.PublicKey(CONFIG.SOLANA_MINT);
          const accounts = await state.solanaConnection.getParsedTokenAccountsByOwner(
            state.solanaPublicKey,
            { mint }
          );
          
          if (accounts.value.length > 0) {
            const amount = accounts.value[0].account.data.parsed.info.tokenAmount.uiAmount;
            balance = amount;
          } else {
            balance = 0;
          }
        } else {
          // EVM chain
          if (!state.provider || !state.wallet) {
            balanceEl.textContent = 'Connect wallet';
            return;
          }
          
          const contract = new ethers.Contract(chain.contract, OFT_ABI, state.provider);
          const bal = await contract.balanceOf(state.wallet);
          balance = parseFloat(ethers.utils.formatUnits(bal, CONFIG.TOKEN_DECIMALS));
        }
        
        balanceEl.textContent = `Balance: ${balance.toFixed(2)} ROOT5`;
        
        // Update main balance display if this is the selected source chain
        if (state.sourceChain === chainKey) {
          document.getElementById('sourceBalance').textContent = balance.toFixed(2);
        }
      } catch (error) {
        log(`Error loading balance for ${chainKey}: ${error.message}`, 'error');
        balanceEl.textContent = 'Error';
      }
    }

    // ==================== UI MANAGEMENT ====================
    function init() {
      renderChainGrids();
      updateBridgeButton();
      
      // Detect wallets on load
      const wallets = detectWallets();
      log(`Initialization complete. Available wallets: ${Object.keys(wallets).filter(k => wallets[k]).join(', ')}`);
    }

    function renderChainGrids() {
      const sourceGrid = document.getElementById('sourceChainGrid');
      const destGrid = document.getElementById('destChainGrid');
      
      sourceGrid.innerHTML = '';
      destGrid.innerHTML = '';
      
      Object.entries(CONFIG.CHAINS).forEach(([key, chain]) => {
        const sourceCard = createChainCard(key, chain, 'source');
        const destCard = createChainCard(key, chain, 'dest');
        sourceGrid.appendChild(sourceCard);
        destGrid.appendChild(destCard);
      });
    }

    function createChainCard(key, chain, type) {
      const card = document.createElement('div');
      card.className = 'chain-card';
      card.dataset.chain = key;
      
      const isConnected = state.connectedChain === key;
      const isSelected = (type === 'source' && state.sourceChain === key) || 
                         (type === 'dest' && state.destChain === key);
      
      if (isSelected) {
        card.classList.add('selected');
      }
      
      card.innerHTML = `
        <div class="chain-name">
          ${chain.icon} ${chain.name}
          ${isConnected ? '<span style="color: var(--success); font-size: 0.75rem; margin-left: 5px;">‚óè Connected</span>' : ''}
        </div>
        <div class="chain-balance" id="${type}-balance-${key}">Balance: -</div>
      `;
      
      card.onclick = () => selectChain(key, type);
      return card;
    }

    async function selectChain(chainKey, type) {
      const chain = CONFIG.CHAINS[chainKey];
      
      if (type === 'source') {
        // Deselect all source chains
        document.querySelectorAll('#sourceChainGrid .chain-card').forEach(c => c.classList.remove('selected'));
        document.querySelector(`#sourceChainGrid .chain-card[data-chain="${chainKey}"]`).classList.add('selected');
        state.sourceChain = chainKey;
        
        // Auto-switch if wallet is connected
        if (state.wallet && state.connectedChain !== chainKey) {
          if (chain.chainId === 'solana' && state.walletType !== 'phantom-solana') {
            showStatus('‚ö†Ô∏è Solana requires Phantom wallet. Please reconnect with Phantom.', 'warning');
            return;
          }
          
          if (state.connectedChain === 'solanaDevnet' && chain.chainId !== 'solana') {
            showStatus('‚ö†Ô∏è Please reconnect with MetaMask or Phantom (EVM) to use EVM chains.', 'warning');
            return;
          }
          
          if (chain.chainId !== 'solana') {
            try {
              showStatus(`Switching to ${chain.name}...`, 'info');
              await ensureChain(chainKey);
              showStatus(`‚úÖ Switched to ${chain.name}`, 'success');
            } catch (error) {
              showStatus(`‚ö†Ô∏è ${error.message}`, 'warning');
            }
          }
        }
        
        // Load balance
        if (state.wallet) {
          await loadBalance(chainKey);
        }
      } else {
        // Deselect all dest chains
        document.querySelectorAll('#destChainGrid .chain-card').forEach(c => c.classList.remove('selected'));
        document.querySelector(`#destChainGrid .chain-card[data-chain="${chainKey}"]`).classList.add('selected');
        state.destChain = chainKey;
      }
      
      updateBridgeButton();
    }

    function updateWalletDisplay() {
      document.getElementById('connectBtn').style.display = 'none';
      document.getElementById('walletInfo').style.display = 'flex';
      document.getElementById('disconnectBtn').style.display = 'inline-flex';
      
      const shortAddress = state.wallet.length > 42 
        ? `${state.wallet.slice(0, 4)}...${state.wallet.slice(-4)}`
        : `${state.wallet.slice(0, 6)}...${state.wallet.slice(-4)}`;
      
      document.getElementById('walletAddress').textContent = shortAddress;
      document.getElementById('walletChain').textContent = state.connectedChain 
        ? CONFIG.CHAINS[state.connectedChain].name 
        : 'Unknown';
      
      renderChainGrids();
      
      // Auto-select connected chain as source
      if (state.connectedChain && !state.sourceChain) {
        selectChain(state.connectedChain, 'source');
      }
    }

    function updateBridgeButton() {
      const btn = document.getElementById('bridgeBtn');
      const canBridge = state.wallet && state.sourceChain && state.destChain && 
                        state.sourceChain !== state.destChain;
      btn.disabled = !canBridge;
    }

    // ==================== BRIDGE EXECUTION ====================
    async function executeBridge() {
      if (!state.sourceChain || !state.destChain || !state.wallet) {
        showStatus('Please connect wallet and select chains', 'error');
        return;
      }
      
      const amount = document.getElementById('amountInput').value;
      if (!amount || parseFloat(amount) <= 0) {
        showStatus('Please enter a valid amount', 'error');
        return;
      }
      
      const btn = document.getElementById('bridgeBtn');
      const originalText = btn.innerHTML;
      btn.disabled = true;
      btn.innerHTML = '<div class="loading"><div class="spinner"></div> Bridging...</div>';
      
      try {
        if (state.sourceChain === 'solanaDevnet') {
          await bridgeFromSolana(amount);
        } else {
          await bridgeFromEVM(amount);
        }
      } catch (error) {
        log(`Bridge error: ${error.message}`, 'error');
        showStatus(`‚ùå Bridge failed: ${error.message}`, 'error');
      } finally {
        btn.disabled = false;
        btn.innerHTML = originalText;
      }
    }

    async function bridgeFromEVM(amount) {
      showStatus('Preparing bridge transaction...', 'info');
      
      const sourceChain = CONFIG.CHAINS[state.sourceChain];
      const destChain = CONFIG.CHAINS[state.destChain];
      
      // Ensure we're on the right chain
      await ensureChain(state.sourceChain);
      
      const contract = new ethers.Contract(sourceChain.contract, OFT_ABI, state.signer);
      
      // Parse amount
      const amountLD = ethers.utils.parseUnits(amount, CONFIG.TOKEN_DECIMALS);
      
      // Get recipient
      let recipientInput = document.getElementById('recipientInput').value.trim();
      let toAddressBytes32;
      
      if (!recipientInput) {
        if (destChain.chainId === 'solana') {
          throw new Error('Please specify a Solana recipient address');
        }
        toAddressBytes32 = addressToBytes32(state.wallet);
      } else {
        if (destChain.chainId === 'solana') {
          toAddressBytes32 = solanaAddressToBytes32(recipientInput);
        } else {
          toAddressBytes32 = addressToBytes32(recipientInput);
        }
      }
      
      // Build send params
      const sendParam = {
        dstEid: destChain.lzEid,
        to: toAddressBytes32,
        amountLD: amountLD,
        minAmountLD: amountLD,
        extraOptions: '0x',
        composeMsg: '0x',
        oftCmd: '0x'
      };
      
      // Quote fee
      showStatus('Calculating bridge fee...', 'info');
      const quote = await contract.quoteSend(sendParam, false);
      
      const feeInEth = ethers.utils.formatEther(quote.nativeFee);
      showStatus(`Bridge fee: ${feeInEth} ETH - Approve transaction in wallet...`, 'info');
      
      // Send transaction
      const tx = await contract.send(
        sendParam,
        { nativeFee: quote.nativeFee, lzTokenFee: 0 },
        state.wallet,
        { value: quote.nativeFee }
      );
      
      showStatus(`Transaction submitted! Hash: ${tx.hash}`, 'info');
      
      // Wait for confirmation
      await tx.wait();
      
      const explorerLink = `${sourceChain.explorer}/tx/${tx.hash}`;
      showStatus(
        `‚úÖ Bridge successful! <a href="${explorerLink}" target="_blank" class="tx-link">View transaction</a>`,
        'success'
      );
      
      // Reload balances
      setTimeout(() => {
        if (state.sourceChain) loadBalance(state.sourceChain);
        if (state.destChain) loadBalance(state.destChain);
      }, 3000);
    }

    async function bridgeFromSolana(amount) {
      log('=== Starting Solana ‚Üí EVM Bridge ===');
      
      if (!state.solanaConnection || !state.solanaPublicKey) {
        throw new Error('Solana wallet not connected');
      }
      
      const destChain = CONFIG.CHAINS[state.destChain];
      
      showStatus(`Preparing Solana bridge to ${destChain.name}...`, 'info');
      
      // Note: Full Solana OFT implementation requires the exact program structure
      // This is a simplified demonstration
      showStatus(
        `‚ö†Ô∏è Solana bridging requires the LayerZero Solana program. Please ensure your OFT program is properly configured with peer addresses. For testing, use EVM ‚Üí EVM or EVM ‚Üí Solana transfers.`,
        'warning'
      );
      
      throw new Error('Solana bridging not fully implemented. Please use EVM chains as source.');
    }

    // ==================== UTILITY FUNCTIONS ====================
    function addressToBytes32(address) {
      const addr = address.toLowerCase().replace('0x', '');
      return '0x' + addr.padStart(64, '0');
    }

    function solanaAddressToBytes32(solAddress) {
      try {
        const pubkey = new solanaWeb3.PublicKey(solAddress);
        const bytes = pubkey.toBytes();
        return '0x' + Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
      } catch (error) {
        throw new Error('Invalid Solana address');
      }
    }

    // ==================== INITIALIZATION ====================
    window.addEventListener('load', () => {
      log('=== ROOT5 Bridge Interface Loaded ===');
      
      const wallets = detectWallets();
      if (wallets.metamask) log('‚úÖ MetaMask available');
      if (wallets.phantom || wallets.phantomSolana) log('‚úÖ Phantom available');
      if (wallets.coinbase) log('‚úÖ Coinbase Wallet available');
      
      init();
      showStatus('üëã Welcome! Connect your wallet to get started.', 'info');
    });
  </script>
</body>
</html>
